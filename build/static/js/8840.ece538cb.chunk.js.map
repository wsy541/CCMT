{"version":3,"file":"static/js/8840.ece538cb.chunk.js","mappings":";sOAGaA,EAAb,mFACE,SAAaC,EAAOC,GAClB,IAAMC,EAAUF,EAAMG,WAChBC,GAAMC,EAAAA,EAAAA,QAAOH,GAAW,IACxBI,EAAS,IAAIC,EAAYN,GAC/BO,EAAAA,EAAAA,QAAAA,KAA6BF,EAAQF,GAErC,IACEK,EACEH,EADFG,OAGF,MAAoB,WAAhBA,EAAOC,KACF,CACLC,SAAU,CAAC,CACTC,MAAM,eAAD,OAAOH,EAAOI,QAErBC,MAAOL,EAAOK,OAIX,CACLH,SAAU,QArBhB,KAkCMJ,EAAAA,WACJ,WAAYN,IAAW,eACrBc,KAAKd,SAAWA,EAoBjB,OAnBA,mCAED,SAAYe,GACV,IAAKD,KAAKN,OAAQ,CAChBQ,QAAQC,IAAIF,GACZ,IAAMF,EAfc,SAAAK,GAAU,IAAD,EAC3BC,EAAkBD,EAAME,KACxBC,EAAcH,EAAMI,mBAAqB,EACzCC,GAAS,UAAAL,EAAMM,YAAN,eAAYD,SAAU,EACrC,OAAO,IAAIE,EAAAA,MAAaN,EAAiBE,EAAaF,EAAiBE,EAAcE,GAWnEG,CAAkBX,EAAIY,OACpBF,EAAAA,MAAAA,iBAA8BZ,EAAOC,KAAKd,YAGxDc,KAAKN,OAAS,CACZK,MAAAA,EACAJ,KAAM,SACNG,KAAMG,EAAIY,MAAMH,UAIvB,4BAED,gBACC,EAtBGlB,+EC7BN,eACA,WACA,WAGaC,EAAA,gEASL,SAAkCqB,EAAaC,GAOrD,IANA,IAAIC,EAAyB,GACzBC,EAAuB,GAEvBC,EAAqCH,EACrCI,EAAuB,EAEpBD,GAeN,GAbIA,aAAuB,EAAAE,UACtBN,EAASO,gBACZP,EAASO,eAAeH,GAEfA,aAAuB,EAAAI,aAC7BR,EAASS,eACZT,EAASS,cAAcL,GAGxBlB,KAAKwB,UAAUV,EAAUI,GAItBA,EAAYO,WAAa,EAC5BT,EAAUU,KAAKR,GACfD,EAAWS,KAAKP,GAChBA,EAAe,EACfD,EAAcA,EAAYS,SAAS,QAKpC,EAAG,CAOF,GALIT,aAAuB,EAAAU,UAC1B5B,KAAK6B,SAASf,EAAUI,GAIA,IAArBF,EAAUP,OAAc,CAC3BS,OAAcY,EACdX,EAAe,EACf,MAID,IAAIY,EAAOf,EAAUA,EAAUP,OAAS,GAGxC,GADAS,IADAC,EAC6BY,EAAKN,WAAaM,EAAKJ,SAASR,QAAgBW,EAE5E,MAIDZ,EAAcF,EAAUgB,MACxBb,EAAeF,EAAWe,YAClBd,4BAUD,SAAUJ,EAA6BmB,GAChD,IAAIhC,EAAMgC,EAAEC,YACRpB,EAASqB,gBACZrB,EAASqB,eAAelC,GAGzBA,EAAIuB,UAAUV,2BASL,SAASA,EAA6BmB,GAC/C,IAAIhC,EAAMgC,EAAEC,YACZjC,EAAI4B,SAASf,GACTA,EAASsB,eACZtB,EAASsB,cAAcnC,SA7Fb,GAAb,MAkGA,SAAiBR,GACH,EAAA4C,QAA2B,IAAI5C,EAD7C,CAAiBA,EAAA,UAAe","sources":["pages/events/add/HoverProvider.ts","tree/ParseTreeWalker.ts"],"sourcesContent":["import { ParseTreeWalker } from 'antlr4ts/tree/ParseTreeWalker';\nimport * as monaco from 'monaco-editor/esm/vs/editor/editor.api';\nimport { getAST } from './common';\nexport class HoverProvider {\n  provideHover(model, position) {\n    const content = model.getValue();\n    const AST = getAST(content || '');\n    const finder = new HoverFinder(position);\n    ParseTreeWalker.DEFAULT.walk(finder, AST); // 遍历AST\n\n    const {\n      result\n    } = finder;\n\n    if (result.type === 'number') {\n      return {\n        contents: [{\n          value: `数字${result.name}`\n        }],\n        range: result.range\n      };\n    }\n\n    return {\n      contents: []\n    };\n  }\n\n}\n\nconst getRangeFromToken = input => {\n  const startLineNumber = input.line;\n  const startColumn = input.charPositionInLine + 1;\n  const length = input.text?.length || 1;\n  return new monaco.Range(startLineNumber, startColumn, startLineNumber, startColumn + length);\n};\n\nclass HoverFinder {\n  constructor(position) {\n    this.position = position;\n  }\n\n  enterNumber(ctx) {\n    if (!this.result) {\n      console.log(ctx);\n      const range = getRangeFromToken(ctx.start);\n      const matched = monaco.Range.containsPosition(range, this.position);\n\n      if (matched) {\n        this.result = {\n          range,\n          type: 'number',\n          name: ctx.start.text\n        };\n      }\n    }\n  }\n\n  visitErrorNode() {// 为了ts类型正确\n  }\n\n}","/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:47.8252451-07:00\r\nimport { ParseTree } from \"./ParseTree\";\r\nimport { ParseTreeListener } from \"./ParseTreeListener\";\r\nimport { ErrorNode } from \"./ErrorNode\";\r\nimport { TerminalNode } from \"./TerminalNode\";\r\nimport { RuleNode } from \"./RuleNode\";\r\nimport { ParserRuleContext } from \"../ParserRuleContext\";\r\n\r\nexport class ParseTreeWalker {\r\n\t/**\r\n\t * Performs a walk on the given parse tree starting at the root and going down recursively\r\n\t * with depth-first search. On each node, {@link ParseTreeWalker#enterRule} is called before\r\n\t * recursively walking down into child nodes, then\r\n\t * {@link ParseTreeWalker#exitRule} is called after the recursive call to wind up.\r\n\t * @param listener The listener used by the walker to process grammar rules\r\n\t * @param t The parse tree to be walked on\r\n\t */\r\n\tpublic walk<T extends ParseTreeListener>(listener: T, t: ParseTree): void {\r\n\t\tlet nodeStack: ParseTree[] = [];\r\n\t\tlet indexStack: number[] = [];\r\n\r\n\t\tlet currentNode: ParseTree | undefined = t;\r\n\t\tlet currentIndex: number = 0;\r\n\r\n\t\twhile (currentNode) {\r\n\t\t\t// pre-order visit\r\n\t\t\tif (currentNode instanceof ErrorNode) {\r\n\t\t\t\tif (listener.visitErrorNode) {\r\n\t\t\t\t\tlistener.visitErrorNode(currentNode);\r\n\t\t\t\t}\r\n\t\t\t} else if (currentNode instanceof TerminalNode) {\r\n\t\t\t\tif (listener.visitTerminal) {\r\n\t\t\t\t\tlistener.visitTerminal(currentNode);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.enterRule(listener, currentNode as RuleNode);\r\n\t\t\t}\r\n\r\n\t\t\t// Move down to first child, if exists\r\n\t\t\tif (currentNode.childCount > 0) {\r\n\t\t\t\tnodeStack.push(currentNode);\r\n\t\t\t\tindexStack.push(currentIndex);\r\n\t\t\t\tcurrentIndex = 0;\r\n\t\t\t\tcurrentNode = currentNode.getChild(0);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// No child nodes, so walk tree\r\n\t\t\tdo {\r\n\t\t\t\t// post-order visit\r\n\t\t\t\tif (currentNode instanceof RuleNode) {\r\n\t\t\t\t\tthis.exitRule(listener, currentNode);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// No parent, so no siblings\r\n\t\t\t\tif (nodeStack.length === 0) {\r\n\t\t\t\t\tcurrentNode = undefined;\r\n\t\t\t\t\tcurrentIndex = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move to next sibling if possible\r\n\t\t\t\tlet last = nodeStack[nodeStack.length - 1];\r\n\t\t\t\tcurrentIndex++;\r\n\t\t\t\tcurrentNode = currentIndex < last.childCount ? last.getChild(currentIndex) : undefined;\r\n\t\t\t\tif (currentNode) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// No next sibling, so move up\r\n\t\t\t\tcurrentNode = nodeStack.pop();\r\n\t\t\t\tcurrentIndex = indexStack.pop()!;\r\n\t\t\t} while (currentNode);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener#enterEveryRule}\r\n\t * then by triggering the event specific to the given parse tree node\r\n\t * @param listener The listener responding to the trigger events\r\n\t * @param r The grammar rule containing the rule context\r\n\t */\r\n\tprotected enterRule(listener: ParseTreeListener, r: RuleNode): void {\r\n\t\tlet ctx = r.ruleContext as ParserRuleContext;\r\n\t\tif (listener.enterEveryRule) {\r\n\t\t\tlistener.enterEveryRule(ctx);\r\n\t\t}\r\n\r\n\t\tctx.enterRule(listener);\r\n\t}\r\n\r\n\t/**\r\n\t * Exits a grammar rule by first triggering the event specific to the given parse tree node\r\n\t * then by triggering the generic event {@link ParseTreeListener#exitEveryRule}\r\n\t * @param listener The listener responding to the trigger events\r\n\t * @param r The grammar rule containing the rule context\r\n\t */\r\n\tprotected exitRule(listener: ParseTreeListener, r: RuleNode): void {\r\n\t\tlet ctx = r.ruleContext as ParserRuleContext;\r\n\t\tctx.exitRule(listener);\r\n\t\tif (listener.exitEveryRule) {\r\n\t\t\tlistener.exitEveryRule(ctx);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport namespace ParseTreeWalker {\r\n\texport const DEFAULT: ParseTreeWalker = new ParseTreeWalker();\r\n}\r\n"],"names":["HoverProvider","model","position","content","getValue","AST","getAST","finder","HoverFinder","ParseTreeWalker","result","type","contents","value","name","range","this","ctx","console","log","input","startLineNumber","line","startColumn","charPositionInLine","length","text","monaco","getRangeFromToken","start","listener","t","nodeStack","indexStack","currentNode","currentIndex","ErrorNode","visitErrorNode","TerminalNode","visitTerminal","enterRule","childCount","push","getChild","RuleNode","exitRule","undefined","last","pop","r","ruleContext","enterEveryRule","exitEveryRule","DEFAULT"],"sourceRoot":""}