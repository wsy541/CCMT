{"version":3,"file":"static/js/4559.8080edd0.chunk.js","mappings":"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","sources":["pages/events/add/HoverProvider.ts","pages/events/add/Linter.ts","pages/events/add/TokenProvider.ts","pages/events/add/registerProvider.ts","pages/events/add/validate.ts","tree/ParseTreeWalker.ts"],"sourcesContent":["import { ParseTreeWalker } from 'antlr4ts/tree/ParseTreeWalker';\nimport * as monaco from 'monaco-editor/esm/vs/editor/editor.api';\nimport { getAST } from './common';\nexport class HoverProvider {\n  provideHover(model, position) {\n    const content = model.getValue();\n    const AST = getAST(content || '');\n    const finder = new HoverFinder(position);\n    ParseTreeWalker.DEFAULT.walk(finder, AST); // 遍历AST\n\n    const {\n      result\n    } = finder;\n\n    if (result.type === 'number') {\n      return {\n        contents: [{\n          value: `数字${result.name}`\n        }],\n        range: result.range\n      };\n    }\n\n    return {\n      contents: []\n    };\n  }\n\n}\n\nconst getRangeFromToken = input => {\n  const startLineNumber = input.line;\n  const startColumn = input.charPositionInLine + 1;\n  const length = input.text?.length || 1;\n  return new monaco.Range(startLineNumber, startColumn, startLineNumber, startColumn + length);\n};\n\nclass HoverFinder {\n  constructor(position) {\n    this.position = position;\n  }\n\n  enterNumber(ctx) {\n    if (!this.result) {\n      console.log(ctx);\n      const range = getRangeFromToken(ctx.start);\n      const matched = monaco.Range.containsPosition(range, this.position);\n\n      if (matched) {\n        this.result = {\n          range,\n          type: 'number',\n          name: ctx.start.text\n        };\n      }\n    }\n  }\n\n  visitErrorNode() {// 为了ts类型正确\n  }\n\n}","import * as monaco from 'monaco-editor/esm/vs/editor/editor.api';\nimport { validate } from './validate';\nimport { debounce } from 'lodash'; // 捕获错误类\n\nexport class Linter {\n  disposables = [];\n  listener = Object.create(null);\n\n  constructor(id) {\n    this.languageId = id;\n\n    const onModelAdd = model => {\n      const modelId = // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore ts error\n      model.getModeId?.() || // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore new Api\n      model.getLanguageId?.();\n\n      if (modelId !== this.languageId) {\n        return;\n      }\n\n      const debouncedDoValidate = debounce(this.doValidate, 500);\n      this.listener[model.uri.toString()] = model.onDidChangeContent(() => {\n        debouncedDoValidate(model);\n      });\n      this.doValidate(model);\n    };\n\n    const onModelRemoved = model => {\n      monaco.editor.setModelMarkers(model, 'ruleLint', []);\n      const uriStr = model.uri.toString();\n      const listener = this.listener[uriStr];\n\n      if (listener) {\n        listener.dispose();\n        delete this.listener[uriStr];\n      }\n    };\n\n    this.disposables.push(monaco.editor.onDidCreateModel(onModelAdd));\n    this.disposables.push(monaco.editor.onWillDisposeModel(onModelRemoved));\n    this.disposables.push(monaco.editor.onDidChangeModelLanguage(event => {\n      onModelRemoved(event.model);\n      onModelAdd(event.model);\n    }));\n    this.disposables.push({\n      dispose: () => {\n        for (const key in this.listener) {\n          this.listener[key].dispose();\n        }\n      }\n    });\n    monaco.editor.getModels().forEach(onModelAdd);\n  }\n\n  dispose() {\n    this.disposables.forEach(item => item?.dispose());\n    this.disposables = [];\n  }\n\n  async doValidate(model) {\n    const errors = await validate(model);\n\n    if (errors) {\n      monaco.editor.setModelMarkers(model, 'ruleLint', errors);\n    }\n  }\n\n}","import { createLexer, TokenMap } from './common';\n\nfunction getTokens(input) {\n  const lexer = createLexer(input); // 捕获词法错误\n\n  const errors = [];\n  lexer.removeErrorListeners();\n  lexer.addErrorListener({\n    syntaxError(_1, _2, _3, charPositionInLine) {\n      errors.push(charPositionInLine);\n    }\n\n  }); // 获取token流\n\n  const tokens = lexer.getAllTokens();\n  console.log(tokens);\n  const res = tokens.map(token => {\n    const type = lexer.ruleNames[token.type - 1];\n    const typeName = TokenMap[type] || TokenMap.UnexpectedCharacter;\n    return {\n      scopes: typeName,\n      startIndex: token.charPositionInLine\n    };\n  }); // 将捕获到的错误加入res中\n\n  errors.forEach(point => res.push({\n    scopes: 'error',\n    startIndex: point\n  }));\n  return res;\n}\n\nfunction tokenForLine(input) {\n  const tokens = getTokens(input);\n  return {\n    tokens,\n    endState: new State()\n  };\n}\n\nclass State {\n  clone() {\n    return new State();\n  }\n\n  equals(other) {\n    return true;\n  }\n\n}\n\nexport class TokensProviders {\n  tokenize(line, state) {\n    return tokenForLine(line);\n  }\n\n  getInitialState() {\n    return new State();\n  }\n\n}","import * as monaco from 'monaco-editor/esm/vs/editor/editor.api';\nimport { HoverProvider } from './HoverProvider';\nimport { Linter } from './Linter';\nimport { TokensProviders } from './TokenProvider';\n\nconst disposeAll = disposables => {\n  disposables.forEach(item => item.dispose());\n};\n\nconst registerDispose = disposables => ({\n  dispose: () => disposeAll(disposables)\n});\n\nexport const registerProvier = id => {\n  const disposables = []; // 注册高亮\n\n  disposables.push(monaco.languages.setTokensProvider(id, new TokensProviders())); // 注册hover提示\n\n  disposables.push(monaco.languages.registerHoverProvider(id, new HoverProvider())); // 注册错误捕获\n\n  disposables.push(new Linter(id));\n  return registerDispose(disposables);\n};","import { CommonTokenStream } from 'antlr4ts';\nimport * as monaco from 'monaco-editor/esm/vs/editor/editor.api';\nimport { createLexer } from './common';\nimport { TodoLangGrammarParser } from '@/ANTLR/TodoLangGrammarParser';\n\nconst getPositionByToken = token => ({\n  startLineNumber: token.line,\n  startColumn: token.charPositionInLine + 1,\n  endLineNumber: token.line,\n  endColumn: token.charPositionInLine + (token.text?.length || 0) + 1\n});\n\nexport const validate = async model => {\n  let content = '';\n\n  try {\n    content = model.getValue();\n    console.log(content);\n  } catch {\n    monaco.editor.setModelMarkers(model, 'ruleLint', []);\n    return;\n  }\n\n  if (!content.trim()) {\n    monaco.editor.setModelMarkers(model, 'ruleLint', []);\n    return;\n  }\n\n  const lexer = createLexer(content);\n  const tokenStream = new CommonTokenStream(lexer);\n  const parser = new TodoLangGrammarParser(tokenStream);\n  lexer.removeErrorListeners();\n  parser.removeErrorListeners();\n  const errors = []; // 收集词法错误和语法错误\n\n  lexer.addErrorListener({\n    syntaxError(_1, _2, line, charPositionInLine, msg, _6) {\n      errors.push({\n        message: msg,\n        severity: monaco.MarkerSeverity.Error,\n        source: 'validator',\n        startLineNumber: line,\n        startColumn: charPositionInLine + 1,\n        endLineNumber: line,\n        endColumn: charPositionInLine + 2,\n        code: 'lexer'\n      });\n    }\n\n  });\n  parser.addErrorListener({\n    syntaxError(_1, offendingSymbol, _3, _4, msg, _6) {\n      if (offendingSymbol) {\n        errors.push({\n          message: msg,\n          severity: monaco.MarkerSeverity.Error,\n          source: 'validator',\n          code: 'parser',\n          ...getPositionByToken(offendingSymbol)\n        });\n      }\n    }\n\n  });\n  parser.tsl();\n  return errors;\n};","/*!\r\n * Copyright 2016 The ANTLR Project. All rights reserved.\r\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\r\n */\r\n\r\n// ConvertTo-TS run at 2016-10-04T11:26:47.8252451-07:00\r\nimport { ParseTree } from \"./ParseTree\";\r\nimport { ParseTreeListener } from \"./ParseTreeListener\";\r\nimport { ErrorNode } from \"./ErrorNode\";\r\nimport { TerminalNode } from \"./TerminalNode\";\r\nimport { RuleNode } from \"./RuleNode\";\r\nimport { ParserRuleContext } from \"../ParserRuleContext\";\r\n\r\nexport class ParseTreeWalker {\r\n\t/**\r\n\t * Performs a walk on the given parse tree starting at the root and going down recursively\r\n\t * with depth-first search. On each node, {@link ParseTreeWalker#enterRule} is called before\r\n\t * recursively walking down into child nodes, then\r\n\t * {@link ParseTreeWalker#exitRule} is called after the recursive call to wind up.\r\n\t * @param listener The listener used by the walker to process grammar rules\r\n\t * @param t The parse tree to be walked on\r\n\t */\r\n\tpublic walk<T extends ParseTreeListener>(listener: T, t: ParseTree): void {\r\n\t\tlet nodeStack: ParseTree[] = [];\r\n\t\tlet indexStack: number[] = [];\r\n\r\n\t\tlet currentNode: ParseTree | undefined = t;\r\n\t\tlet currentIndex: number = 0;\r\n\r\n\t\twhile (currentNode) {\r\n\t\t\t// pre-order visit\r\n\t\t\tif (currentNode instanceof ErrorNode) {\r\n\t\t\t\tif (listener.visitErrorNode) {\r\n\t\t\t\t\tlistener.visitErrorNode(currentNode);\r\n\t\t\t\t}\r\n\t\t\t} else if (currentNode instanceof TerminalNode) {\r\n\t\t\t\tif (listener.visitTerminal) {\r\n\t\t\t\t\tlistener.visitTerminal(currentNode);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.enterRule(listener, currentNode as RuleNode);\r\n\t\t\t}\r\n\r\n\t\t\t// Move down to first child, if exists\r\n\t\t\tif (currentNode.childCount > 0) {\r\n\t\t\t\tnodeStack.push(currentNode);\r\n\t\t\t\tindexStack.push(currentIndex);\r\n\t\t\t\tcurrentIndex = 0;\r\n\t\t\t\tcurrentNode = currentNode.getChild(0);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// No child nodes, so walk tree\r\n\t\t\tdo {\r\n\t\t\t\t// post-order visit\r\n\t\t\t\tif (currentNode instanceof RuleNode) {\r\n\t\t\t\t\tthis.exitRule(listener, currentNode);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// No parent, so no siblings\r\n\t\t\t\tif (nodeStack.length === 0) {\r\n\t\t\t\t\tcurrentNode = undefined;\r\n\t\t\t\t\tcurrentIndex = 0;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Move to next sibling if possible\r\n\t\t\t\tlet last = nodeStack[nodeStack.length - 1];\r\n\t\t\t\tcurrentIndex++;\r\n\t\t\t\tcurrentNode = currentIndex < last.childCount ? last.getChild(currentIndex) : undefined;\r\n\t\t\t\tif (currentNode) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// No next sibling, so move up\r\n\t\t\t\tcurrentNode = nodeStack.pop();\r\n\t\t\t\tcurrentIndex = indexStack.pop()!;\r\n\t\t\t} while (currentNode);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener#enterEveryRule}\r\n\t * then by triggering the event specific to the given parse tree node\r\n\t * @param listener The listener responding to the trigger events\r\n\t * @param r The grammar rule containing the rule context\r\n\t */\r\n\tprotected enterRule(listener: ParseTreeListener, r: RuleNode): void {\r\n\t\tlet ctx = r.ruleContext as ParserRuleContext;\r\n\t\tif (listener.enterEveryRule) {\r\n\t\t\tlistener.enterEveryRule(ctx);\r\n\t\t}\r\n\r\n\t\tctx.enterRule(listener);\r\n\t}\r\n\r\n\t/**\r\n\t * Exits a grammar rule by first triggering the event specific to the given parse tree node\r\n\t * then by triggering the generic event {@link ParseTreeListener#exitEveryRule}\r\n\t * @param listener The listener responding to the trigger events\r\n\t * @param r The grammar rule containing the rule context\r\n\t */\r\n\tprotected exitRule(listener: ParseTreeListener, r: RuleNode): void {\r\n\t\tlet ctx = r.ruleContext as ParserRuleContext;\r\n\t\tctx.exitRule(listener);\r\n\t\tif (listener.exitEveryRule) {\r\n\t\t\tlistener.exitEveryRule(ctx);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport namespace ParseTreeWalker {\r\n\texport const DEFAULT: ParseTreeWalker = new ParseTreeWalker();\r\n}\r\n"],"names":["HoverProvider","model","position","content","getValue","AST","getAST","finder","HoverFinder","ParseTreeWalker","result","type","contents","value","name","range","this","ctx","console","log","input","startLineNumber","line","startColumn","charPositionInLine","length","text","monaco","getRangeFromToken","start","Linter","id","disposables","listener","Object","create","languageId","onModelAdd","getModeId","getLanguageId","debouncedDoValidate","debounce","doValidate","uri","toString","onDidChangeContent","onModelRemoved","uriStr","dispose","push","event","key","forEach","item","validate","errors","tokenForLine","tokens","lexer","createLexer","removeErrorListeners","addErrorListener","syntaxError","_1","_2","_3","getAllTokens","res","map","token","ruleNames","scopes","TokenMap","startIndex","point","getTokens","endState","State","other","TokensProviders","state","registerProvier","disposeAll","registerDispose","getPositionByToken","endLineNumber","endColumn","trim","tokenStream","CommonTokenStream","parser","TodoLangGrammarParser","msg","_6","message","severity","source","code","offendingSymbol","_4","tsl","t","nodeStack","indexStack","currentNode","currentIndex","ErrorNode","visitErrorNode","TerminalNode","visitTerminal","enterRule","childCount","getChild","RuleNode","exitRule","undefined","last","pop","r","ruleContext","enterEveryRule","exitEveryRule","DEFAULT"],"sourceRoot":""}